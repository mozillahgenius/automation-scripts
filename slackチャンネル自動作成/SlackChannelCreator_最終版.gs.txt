/**
 * Slack チャンネル自動作成 Google Apps Script（最終版）
 *
 * 機能:
 * 1. 「フォーム形式の回答」シートに新規データ → 「チャンネル名」シートにコピー＆採番
 * 2. 「チャンネル名」シートのE列に値が入力 → Slackチャンネルを自動作成
 *
 * ============================================
 * セットアップ手順:
 * 1. このファイルの内容を全てコピー
 * 2. Google Apps Script に貼り付け
 * 3. 既存のファイルは全て削除
 * 4. deleteAllTriggers() を実行して不要なトリガーを削除
 * 5. initialSetup() を実行（トークン設定＋トリガー設定）
 * ============================================
 *
 * 重要: 関数名を「onEdit」にすると外部API呼び出しができないため
 *       「onSpreadsheetEdit」という名前を使用しています
 */

// ========================================
// 設定
// ========================================

// Slack Bot Token（xoxb-で始まるトークン）
function getSlackToken() {
  return PropertiesService.getScriptProperties().getProperty('SLACK_BOT_TOKEN');
}

// シート名
const SOURCE_SHEET_NAME = 'フォーム形式の回答';
const TARGET_SHEET_NAME = 'チャンネル名';

// 列番号の設定
const HEADER_ROWS = 1;
const COL_PURPOSE = 1;      // A列: 用途
const COL_NAME = 2;         // B列: 表示名（日本語可）
const COL_CODE = 3;         // C列: 用途コード
const COL_NUMBER = 4;       // D列: チャンネル番号
const COL_SLACK_NAME = 5;   // E列: Slack作成用チャンネル名（入力トリガー）
const COL_VALIDATION = 6;   // F列: バリデーション
const COL_ZAPIER = 7;       // G列: zapier_action
const COL_STATUS = 8;       // H列: Slack作成ステータス（結果出力）

// ========================================
// メイン処理: 編集時トリガー
// ========================================

/**
 * スプレッドシート編集時のトリガー関数
 * ※「onEdit」ではなく「onSpreadsheetEdit」を使用
 *   （onEditだとシンプルトリガーになりUrlFetchAppが使えない）
 * @param {Object} e - イベントオブジェクト
 */
function onSpreadsheetEdit(e) {
  const sheet = e.range.getSheet();
  const sheetName = sheet.getName();

  // 「フォーム形式の回答」シートの編集時
  if (sheetName === SOURCE_SHEET_NAME) {
    // A列（用途）が編集された場合のみ処理
    if (e.range.getColumn() === 1 && e.range.getRow() > HEADER_ROWS) {
      Logger.log('フォーム形式の回答シートに新規データ検出');
      processNewEntry();
    }
    return;
  }

  // 「チャンネル名」シートの編集時
  if (sheetName === TARGET_SHEET_NAME) {
    const row = e.range.getRow();
    const col = e.range.getColumn();

    if (row <= HEADER_ROWS) return;

    // A列（用途）編集時 → 採番処理
    if (col === COL_PURPOSE) {
      handleChannelSheetEdit(e);
    }

    // E列（Slackチャンネル名）編集時 → Slack作成
    if (col === COL_SLACK_NAME) {
      const channelName = e.value;
      if (channelName && channelName.trim() !== '') {
        createSlackChannel(channelName.trim(), sheet, row);
      }
    }
  }
}

/**
 * 変更時トリガー（行挿入対応）
 * @param {Object} e - イベントオブジェクト
 */
function onSpreadsheetChange(e) {
  // 行挿入以外は無視
  if (e.changeType !== 'INSERT_ROW' && e.changeType !== 'EDIT') {
    return;
  }

  processNewEntry();
}

// ========================================
// フォーム回答 → チャンネル名シート処理
// ========================================

/**
 * 「フォーム形式の回答」シートの最新行を処理する
 * 手動実行も可能
 */
function processNewEntry() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = ss.getSheetByName(SOURCE_SHEET_NAME);
  const targetSheet = ss.getSheetByName(TARGET_SHEET_NAME);

  if (!sourceSheet || !targetSheet) {
    Logger.log('エラー: シートが見つかりません');
    return;
  }

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  try {
    const sourceLastRow = sourceSheet.getLastRow();
    if (sourceLastRow <= HEADER_ROWS) {
      Logger.log('フォーム形式の回答シートにデータがありません');
      return;
    }

    // フォーム形式の回答シートの最新行からデータを取得
    const colA = sourceSheet.getRange(sourceLastRow, 1).getValue(); // 用途
    const colB = sourceSheet.getRange(sourceLastRow, 2).getValue(); // チャンネル名

    Logger.log('新規データ検出: 用途=' + colA + ', チャンネル名=' + colB);

    if (!colA) {
      Logger.log('用途が空のためスキップ');
      return;
    }

    // 既に処理済みかチェック
    const targetLastRow = targetSheet.getLastRow();
    if (targetLastRow > HEADER_ROWS) {
      const existingData = targetSheet
        .getRange(HEADER_ROWS + 1, 1, targetLastRow - HEADER_ROWS, 2)
        .getValues();

      for (const row of existingData) {
        if (row[0] === colA && row[1] === colB) {
          Logger.log('既に処理済みのデータです');
          return;
        }
      }
    }

    // 書き込み先行を決定
    let targetRow;
    if (targetLastRow <= HEADER_ROWS) {
      targetRow = HEADER_ROWS + 1;
    } else {
      // A列が空欄の行を探す
      const aColValues = targetSheet
        .getRange(HEADER_ROWS + 1, COL_PURPOSE, targetLastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      targetRow = -1;
      for (let i = 0; i < aColValues.length; i++) {
        if (aColValues[i] === '' || aColValues[i] === null) {
          targetRow = HEADER_ROWS + 1 + i;
          break;
        }
      }

      if (targetRow === -1) {
        targetRow = targetLastRow + 1;
      }
    }

    Logger.log('書き込み先行: ' + targetRow);

    // A列とB列にデータをコピー
    targetSheet.getRange(targetRow, 1).setValue(colA);
    targetSheet.getRange(targetRow, 2).setValue(colB);

    // 採番処理
    const purpose = String(colA).trim();
    const numCell = targetSheet.getRange(targetRow, COL_NUMBER);
    const [minN, maxN] = rangeByPurpose_(purpose);

    Logger.log('番号範囲: ' + minN + '〜' + maxN);

    // 既存番号から最大を探す
    let currentMax = minN - 1;
    if (targetLastRow > HEADER_ROWS) {
      const allValues = targetSheet
        .getRange(HEADER_ROWS + 1, COL_NUMBER, targetLastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      for (const v of allValues) {
        if (typeof v === 'number' && v >= minN && v <= maxN) {
          if (v > currentMax) currentMax = v;
        }
      }
    }

    const nextN = currentMax + 1;
    Logger.log('次の番号: ' + nextN);

    if (nextN > maxN) {
      numCell.setValue('OVER_RANGE');
      Logger.log('警告: 番号範囲を超えました');
    } else {
      numCell.setValue(nextN);
      Logger.log('採番完了: ' + nextN);
    }

  } finally {
    lock.releaseLock();
  }
}

/**
 * 「チャンネル名」シートの手動編集時の採番処理
 */
function handleChannelSheetEdit(e) {
  const sh = e.range.getSheet();
  const row = e.range.getRow();

  if (row <= HEADER_ROWS) return;

  const purpose = String(sh.getRange(row, COL_PURPOSE).getValue() || '').trim();
  if (!purpose) return;

  const numCell = sh.getRange(row, COL_NUMBER);
  const current = numCell.getValue();

  if (typeof current === 'number' && current >= 0) return;
  if (current === 'OVER_RANGE') return;

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  try {
    const recheck = numCell.getValue();
    if (typeof recheck === 'number' && recheck >= 0) return;
    if (recheck === 'OVER_RANGE') return;

    const [minN, maxN] = rangeByPurpose_(purpose);
    const lastRow = sh.getLastRow();
    let currentMax = minN - 1;

    if (lastRow > HEADER_ROWS) {
      const values = sh
        .getRange(HEADER_ROWS + 1, COL_NUMBER, lastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      for (const v of values) {
        if (typeof v === 'number' && v >= minN && v <= maxN) {
          if (v > currentMax) currentMax = v;
        }
      }
    }

    const nextN = currentMax + 1;

    if (nextN > maxN) {
      numCell.setValue('OVER_RANGE');
    } else {
      numCell.setValue(nextN);
    }
  } finally {
    lock.releaseLock();
  }
}

/**
 * 用途に応じた番号範囲を返す
 */
function rangeByPurpose_(purpose) {
  switch (purpose) {
    case 'デフォルト':
    case 'デフォルトチャンネル':
      return [0, 99];
    case '組織':
      return [100, 199];
    case 'プロジェクト':
      return [200, 899];
    case 'プライベート':
      return [900, 999];
    default:
      Logger.log('警告: 未知の用途「' + purpose + '」- デフォルト範囲を使用');
      return [0, 99];
  }
}

// ========================================
// Slack チャンネル作成処理
// ========================================

/**
 * Slackチャンネルを作成
 * @param {string} originalName - 元のチャンネル名（日本語可）
 * @param {Sheet} sheet - シートオブジェクト
 * @param {number} row - 行番号
 */
function createSlackChannel(originalName, sheet, row) {
  const token = getSlackToken();

  if (!token) {
    sheet.getRange(row, COL_STATUS).setValue('エラー: トークン未設定');
    return;
  }

  // チャンネル名を正規化（Slack仕様に合わせる）
  const normalizedName = normalizeChannelName(originalName);

  if (!normalizedName) {
    sheet.getRange(row, COL_STATUS).setValue('エラー: 無効なチャンネル名');
    return;
  }

  // Slack API呼び出し
  const url = 'https://slack.com/api/conversations.create';
  const payload = {
    name: normalizedName,
    is_private: false
  };

  const options = {
    method: 'post',
    headers: {
      'Authorization': 'Bearer ' + token,
      'Content-Type': 'application/json; charset=utf-8'
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());

    if (result.ok) {
      const channelId = result.channel.id;
      const createdName = result.channel.name;
      sheet.getRange(row, COL_STATUS).setValue('✓ 作成完了: ' + createdName);
      console.log('チャンネル作成成功: ' + createdName + ' (ID: ' + channelId + ')');
    } else {
      const errorMessage = getErrorMessage(result.error);
      sheet.getRange(row, COL_STATUS).setValue('✗ エラー: ' + errorMessage);
      console.error('チャンネル作成失敗: ' + result.error);
    }
  } catch (error) {
    sheet.getRange(row, COL_STATUS).setValue('✗ 通信エラー: ' + error.message);
    console.error('通信エラー: ' + error);
  }
}

/**
 * チャンネル名を正規化（Slack仕様に合わせる）
 */
function normalizeChannelName(name) {
  if (!name) return '';

  let normalized = name
    .toLowerCase()
    .replace(/　/g, ' ')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/[^\w\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF\u3400-\u4DBF-]/g, '');

  if (normalized.length > 80) {
    normalized = normalized.substring(0, 80);
  }

  return normalized;
}

/**
 * Slackエラーコードを日本語メッセージに変換
 */
function getErrorMessage(error) {
  const errorMessages = {
    'name_taken': 'このチャンネル名は既に使用されています',
    'invalid_name_required': 'チャンネル名が必要です',
    'invalid_name_punctuation': '使用できない文字が含まれています',
    'invalid_name_maxlength': 'チャンネル名が長すぎます（最大80文字）',
    'invalid_name_specials': '特殊文字は使用できません',
    'invalid_name': '無効なチャンネル名です',
    'no_channel': 'チャンネルが見つかりません',
    'restricted_action': 'この操作は制限されています',
    'method_not_supported_for_channel_type': 'このチャンネルタイプではサポートされていません',
    'missing_scope': '必要な権限がありません（channels:write）',
    'not_authed': '認証されていません',
    'invalid_auth': '無効な認証情報です',
    'token_revoked': 'トークンが無効化されています',
    'ratelimited': 'API制限に達しました。しばらく待ってから再試行してください'
  };

  return errorMessages[error] || error;
}

// ========================================
// セットアップ・テスト用関数
// ========================================

/**
 * Slack Bot Tokenを設定
 */
function setSlackToken() {
  const token = Browser.inputBox('Slack Bot Tokenを入力してください（xoxb-で始まるもの）');
  if (token && token !== 'cancel') {
    PropertiesService.getScriptProperties().setProperty('SLACK_BOT_TOKEN', token);
    Browser.msgBox('トークンを保存しました');
  }
}

/**
 * トークン設定確認
 */
function checkToken() {
  const token = getSlackToken();
  if (token) {
    Browser.msgBox('トークンは設定されています（先頭: ' + token.substring(0, 10) + '...）');
  } else {
    Browser.msgBox('トークンが設定されていません。setSlackToken()を実行してください。');
  }
}

/**
 * 手動でチャンネル作成をテスト
 */
function testCreateChannel() {
  const channelName = Browser.inputBox('作成するチャンネル名を入力してください');
  if (!channelName || channelName === 'cancel') {
    return;
  }

  const token = getSlackToken();
  if (!token) {
    Browser.msgBox('トークンが設定されていません');
    return;
  }

  const normalizedName = normalizeChannelName(channelName);
  Browser.msgBox('正規化後の名前: ' + normalizedName);

  const url = 'https://slack.com/api/conversations.create';
  const payload = {
    name: normalizedName,
    is_private: false
  };

  const options = {
    method: 'post',
    headers: {
      'Authorization': 'Bearer ' + token,
      'Content-Type': 'application/json; charset=utf-8'
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  const result = JSON.parse(response.getContentText());

  if (result.ok) {
    Browser.msgBox('成功！チャンネル「' + result.channel.name + '」を作成しました');
  } else {
    Browser.msgBox('エラー: ' + getErrorMessage(result.error));
  }
}

/**
 * フォーム処理の手動テスト
 */
function testProcessNewEntry() {
  processNewEntry();
  Logger.log('テスト完了');
}

/**
 * E列の特定行でSlack作成をテスト（デバッグ用）
 * 行番号を指定して手動実行
 */
function testSlackCreationForRow() {
  const row = 2; // テストしたい行番号を指定
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(TARGET_SHEET_NAME);

  if (!sheet) {
    Browser.msgBox('シートが見つかりません: ' + TARGET_SHEET_NAME);
    return;
  }

  const channelName = sheet.getRange(row, COL_SLACK_NAME).getValue();
  Browser.msgBox('行' + row + 'のE列の値: ' + channelName);

  if (channelName && String(channelName).trim() !== '') {
    createSlackChannel(String(channelName).trim(), sheet, row);
    Browser.msgBox('処理完了。I列を確認してください。');
  } else {
    Browser.msgBox('E列が空です');
  }
}

// ========================================
// トリガー管理関数
// ========================================

/**
 * 全てのトリガーを削除
 */
function deleteAllTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  let deletedCount = 0;

  triggers.forEach(trigger => {
    ScriptApp.deleteTrigger(trigger);
    deletedCount++;
  });

  Browser.msgBox(deletedCount + '個のトリガーを全て削除しました');
}

/**
 * 現在のトリガー一覧を表示
 */
function listAllTriggers() {
  const triggers = ScriptApp.getProjectTriggers();

  if (triggers.length === 0) {
    Browser.msgBox('トリガーはありません');
    return;
  }

  let message = '現在のトリガー一覧:\n\n';
  triggers.forEach((trigger, index) => {
    message += (index + 1) + '. ' + trigger.getHandlerFunction() +
               ' (' + trigger.getEventType() + ')\n';
  });

  Browser.msgBox(message);
}

/**
 * 必要なトリガーを設定
 * onSpreadsheetEdit（編集時）と onSpreadsheetChange（変更時）の2つ
 */
function createTriggers() {
  // 既存のトリガーを全て削除
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    ScriptApp.deleteTrigger(trigger);
  });

  const ss = SpreadsheetApp.getActive();

  // onSpreadsheetEdit トリガー（編集時）
  // ※「onEdit」ではなく別名を使うことで、インストール可能トリガーとして
  //   外部API（UrlFetchApp）を呼び出せるようになる
  ScriptApp.newTrigger('onSpreadsheetEdit')
    .forSpreadsheet(ss)
    .onEdit()
    .create();

  // onSpreadsheetChange トリガー（変更時 - 行挿入対応）
  ScriptApp.newTrigger('onSpreadsheetChange')
    .forSpreadsheet(ss)
    .onChange()
    .create();

  Browser.msgBox('トリガーを設定しました:\n1. onSpreadsheetEdit（編集時）\n2. onSpreadsheetChange（変更時）');
}

/**
 * 初期セットアップを一括実行
 */
function initialSetup() {
  // 1. トークン設定
  const token = Browser.inputBox('【1/2】Slack Bot Tokenを入力してください（xoxb-で始まるもの）');
  if (!token || token === 'cancel') {
    Browser.msgBox('セットアップをキャンセルしました');
    return;
  }
  PropertiesService.getScriptProperties().setProperty('SLACK_BOT_TOKEN', token);

  // 2. トリガー設定
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    ScriptApp.deleteTrigger(trigger);
  });

  const ss = SpreadsheetApp.getActive();

  // インストール可能トリガーとして設定（外部API呼び出し可能）
  ScriptApp.newTrigger('onSpreadsheetEdit')
    .forSpreadsheet(ss)
    .onEdit()
    .create();

  ScriptApp.newTrigger('onSpreadsheetChange')
    .forSpreadsheet(ss)
    .onChange()
    .create();

  Browser.msgBox('【2/2】セットアップ完了！\n\n' +
    'トークンを保存し、トリガーを設定しました。\n\n' +
    '動作:\n' +
    '・「フォーム形式の回答」シート → 「チャンネル名」シートにコピー＆採番\n' +
    '・「チャンネル名」シートのE列入力 → Slackチャンネル作成');
}
