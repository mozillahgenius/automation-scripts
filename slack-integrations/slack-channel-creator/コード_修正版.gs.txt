/**
 * フォーム送信時に「チャンネル名」シートへデータをコピーし、採番する
 * トリガー設定: 編集 → 現在のプロジェクトのトリガー → onFormSubmit → スプレッドシートから → フォーム送信時
 *
 * フォーム形式の回答シートの列順:
 * A: チャンネルの用途, B: チャンネル名, C: マネージャー, D: メンバー, E: 送信者, F: タイムスタンプ
 */
function onFormSubmit(e) {
  const TARGET_SHEET = 'チャンネル名';
  const HEADER_ROWS = 1;
  const COL_PURPOSE = 1; // A: 用途
  const COL_NUMBER = 4;  // D: チャンネル番号

  // e.valuesはシートの列順で格納される（タイムスタンプは最後のF列）
  // e.values[0]: チャンネルの用途
  // e.values[1]: チャンネル名
  const colA = e.values[0]; // 用途（チャンネルの用途）
  const colB = e.values[1]; // チャンネル名

  Logger.log('フォーム受信: 用途=' + colA + ', チャンネル名=' + colB);

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const targetSheet = ss.getSheetByName(TARGET_SHEET);
  if (!targetSheet) {
    Logger.log('エラー: チャンネル名シートが見つかりません');
    return;
  }

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  try {
    const lastRow = targetSheet.getLastRow();
    let targetRow;

    // シートが空（ヘッダーのみ）の場合は2行目に追加
    if (lastRow <= HEADER_ROWS) {
      targetRow = HEADER_ROWS + 1;
    } else {
      // 「チャンネル名」シートのA列が空欄の行を探す
      const aColValues = targetSheet
        .getRange(HEADER_ROWS + 1, COL_PURPOSE, lastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      targetRow = -1;
      for (let i = 0; i < aColValues.length; i++) {
        if (aColValues[i] === '' || aColValues[i] === null) {
          targetRow = HEADER_ROWS + 1 + i;
          break;
        }
      }

      // 空欄の行が見つからない場合は最後の行の次に追加
      if (targetRow === -1) {
        targetRow = lastRow + 1;
      }
    }

    Logger.log('書き込み先行: ' + targetRow);

    // A列とB列にデータをコピー
    targetSheet.getRange(targetRow, 1).setValue(colA); // A列: 用途
    targetSheet.getRange(targetRow, 2).setValue(colB); // B列: 表示名

    // 採番処理
    const purpose = String(colA || '').trim();
    if (!purpose) {
      Logger.log('エラー: 用途が空です');
      return;
    }

    const numCell = targetSheet.getRange(targetRow, COL_NUMBER);

    // 用途に応じた番号範囲を取得
    const [minN, maxN] = rangeByPurpose_(purpose);
    Logger.log('番号範囲: ' + minN + '〜' + maxN);

    // 既存番号から最大を探す（現在のシートから）
    let currentMax = minN - 1;

    if (lastRow > HEADER_ROWS) {
      const allValues = targetSheet
        .getRange(HEADER_ROWS + 1, COL_NUMBER, lastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      for (const v of allValues) {
        if (typeof v === 'number' && v >= minN && v <= maxN) {
          if (v > currentMax) currentMax = v;
        }
      }
    }

    const nextN = currentMax + 1;
    Logger.log('次の番号: ' + nextN);

    if (nextN > maxN) {
      numCell.setValue('OVER_RANGE');
      Logger.log('警告: 番号範囲を超えました');
    } else {
      numCell.setValue(nextN);
      Logger.log('採番完了: ' + nextN);
    }
  } finally {
    lock.releaseLock();
  }
}

function onEdit(e) {
  const SHEET_NAME = 'チャンネル名';
  const HEADER_ROWS = 1;

  const COL_PURPOSE = 1; // A: 用途
  const COL_NUMBER  = 4; // D: チャンネル番号

  const sh = e.range.getSheet();
  if (sh.getName() !== SHEET_NAME) return;

  const row = e.range.getRow();
  const col = e.range.getColumn();
  if (row <= HEADER_ROWS) return;

  // 用途(A列)が編集された時だけ採番する
  if (col !== COL_PURPOSE) return;

  const purpose = String(sh.getRange(row, COL_PURPOSE).getValue() || '').trim();
  if (!purpose) return;

  const numCell = sh.getRange(row, COL_NUMBER);
  const current = numCell.getValue();

  // 既に採番済みなら何もしない
  if (typeof current === 'number' && current >= 0) return;
  if (current === 'OVER_RANGE') return;

  const lock = LockService.getDocumentLock();
  lock.waitLock(30000);

  try {
    // ロック後に再チェック（同時編集対策）
    const recheck = numCell.getValue();
    if (typeof recheck === 'number' && recheck >= 0) return;
    if (recheck === 'OVER_RANGE') return;

    const [minN, maxN] = rangeByPurpose_(purpose);

    // 既存番号から最大を探す
    const lastRow = sh.getLastRow();
    let currentMax = minN - 1;

    if (lastRow > HEADER_ROWS) {
      const values = sh
        .getRange(HEADER_ROWS + 1, COL_NUMBER, lastRow - HEADER_ROWS, 1)
        .getValues()
        .flat();

      for (const v of values) {
        if (typeof v === 'number' && v >= minN && v <= maxN) {
          if (v > currentMax) currentMax = v;
        }
      }
    }

    const nextN = currentMax + 1;

    if (nextN > maxN) {
      numCell.setValue('OVER_RANGE');
      return;
    }

    numCell.setValue(nextN);
  } finally {
    lock.releaseLock();
  }
}

/**
 * 用途に応じた番号範囲を返す
 * - デフォルト:   0〜99
 * - 組織:         100〜199
 * - プロジェクト: 200〜899
 * - プライベート: 900〜999
 *
 * 注意: フォームの選択肢と完全一致させること
 */
function rangeByPurpose_(purpose) {
  switch (purpose) {
    case 'デフォルト':
    case 'デフォルトチャンネル':
      return [0, 99];
    case '組織':
      return [100, 199];
    case 'プロジェクト':
      return [200, 899];
    case 'プライベート':
      return [900, 999];
    default:
      Logger.log('警告: 未知の用途「' + purpose + '」- デフォルト範囲を使用');
      return [0, 99];
  }
}

/**
 * onFormSubmitのテスト用関数（手動実行可能）
 */
function testOnFormSubmit() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = ss.getSheetByName('フォーム形式の回答');

  if (!sourceSheet) {
    Logger.log('エラー: フォーム形式の回答シートが見つかりません');
    return;
  }

  const lastRow = sourceSheet.getLastRow();
  if (lastRow < 2) {
    Logger.log('エラー: フォーム形式の回答シートにデータがありません');
    return;
  }

  // フォーム形式の回答シートの最後の行からデータを取得
  // A列: チャンネルの用途, B列: チャンネル名
  const colA = sourceSheet.getRange(lastRow, 1).getValue();
  const colB = sourceSheet.getRange(lastRow, 2).getValue();

  Logger.log('テストデータ: 用途=' + colA + ', チャンネル名=' + colB);

  // モックイベントを作成（タイムスタンプなし、シートの列順通り）
  const mockEvent = {
    values: [colA, colB]
  };

  onFormSubmit(mockEvent);
  Logger.log('テスト完了: チャンネル名シートを確認してください');
}

/**
 * デバッグ用: e.valuesの内容を確認する
 */
function debugFormSubmit(e) {
  Logger.log('e.values の内容:');
  if (e && e.values) {
    for (let i = 0; i < e.values.length; i++) {
      Logger.log('  [' + i + ']: ' + e.values[i]);
    }
  } else {
    Logger.log('e.values が存在しません');
  }
}
